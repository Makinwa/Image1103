// Generated by CoffeeScript 1.10.0
(function() {
  var Broker, BrokerOp, Promise;

  Promise = require("promise");

  Broker = (function() {
    function Broker(name, retry_limit) {
      this.retrial_limit = retry_limit;
      this.name = name;
      this.transaction_bucket = {
        'insert': {},
        'insert_retry': {},
        'insert_rank': {},
        'delete': {},
        'delete_retry': {},
        'delete_rank': {},
        'update': {},
        'update_retry': {},
        'update_rank': {},
        'read': {},
        'read_retry': {},
        'read_rank': {},
        'create': {},
        'create_retry': {},
        'create_rank': {}
      };
    }

    Broker.prototype.__cleanup = function(op_label, op_key) {
      delete this.transaction_bucket[op_label][op_key];
      delete this.transaction_bucket[op_label + '_rank'][op_key];
      return delete this.transaction_bucket[op_label + '_retry'][op_key];
    };

    Broker.prototype.execute = function() {
      var deferred_read, key, op_label, op_rank, op_retry, op_transaction, self, value;
      if (arguments.length < 3) {
        throw new Error("3 paramaters at least should be passed broker operation (operation, label, key)");
      }
      op_transaction = arguments[0];
      op_label = arguments[1];
      key = arguments[2];
      value = arguments[3];
      op_rank = op_label + "_rank";
      op_retry = op_label + "_retry";
      if (this.transaction_bucket[op_label][key]) {
        this.transaction_bucket[op_rank][key] += 1;
        return this.transaction_bucket[op_label][key];
      }
      self = this;
      deferred_read = new Promise(function(fulfill, reject) {
        var deferred_transaction, transaction;
        transaction = new op_transaction(key, value);
        deferred_transaction = transaction.commit();
        deferred_transaction.then(function(result) {
          self.__cleanup(op_label, key);
          return fulfill(result);
        });
        return deferred_transaction["catch"](function(error) {
          var newTrans, oldTrans;
          if (self.transaction_bucket[op_retry][key] <= self.retrial_limit && self.transaction_bucket[op_rank][key] > self.transaction_bucket[op_retry][key]) {
            oldTrans = self.transaction_bucket[op_label][key];
            delete self.transaction_bucket[op_label][key];
            newTrans = self.execute(op_transaction, op_label, key, arguments[3]);
            self.transaction_bucket[op_retry][key] += 1;
            return fulfill(newTrans);
          } else {
            self.__cleanup(op_label, key);
            return reject(error);
          }
        });
      });
      this.transaction_bucket[op_label][key] = deferred_read;
      if (!this.transaction_bucket[op_rank][key]) {
        this.transaction_bucket[op_rank][key] = 0;
      }
      if (!this.transaction_bucket[op_retry][key]) {
        this.transaction_bucket[op_retry][key] = 0;
      } else {
        this.transaction_bucket[op_retry][key] += 1;
      }
      return deferred_read;
    };

    return Broker;

  })();

  BrokerOp = (function() {
    function BrokerOp(key1) {
      this.key = key1;
      return;
    }

    return BrokerOp;

  })();

  module.exports = {
    'Broker': Broker,
    'BrokerOp': BrokerOp
  };

}).call(this);
